{
  "version": 3,
  "sources": ["../../../../../src/constructs/aws/queue/sqs.ts"],
  "sourcesContent": ["import type {\n    DeleteMessageBatchRequest,\n    DeleteMessageBatchResult,\n    Message,\n    ReceiveMessageRequest,\n    ReceiveMessageResult,\n    SendMessageBatchRequest,\n    SendMessageBatchResult,\n} from \"aws-sdk/clients/sqs\";\nimport type { AwsProvider } from \"@lift/providers\";\nimport { chunk } from \"lodash\";\nimport { sleep } from \"../../../utils/sleep\";\nimport { getUtils } from \"../../../utils/logger\";\n\ntype ProgressCallback = (numberOfMessagesFound: number) => void;\n\nexport async function pollMessages({\n    aws,\n    queueUrl,\n    progressCallback,\n    visibilityTimeout,\n}: {\n    aws: AwsProvider;\n    queueUrl: string;\n    progressCallback?: ProgressCallback;\n    visibilityTimeout?: number;\n}): Promise<Message[]> {\n    const messages: Message[] = [];\n    const promises = [];\n    /**\n     * Poll in parallel to hit multiple SQS servers at once\n     * See https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html\n     * and https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_ReceiveMessage.html\n     * (a single request might not return all messages)\n     */\n    for (let i = 0; i < 3; i++) {\n        promises.push(\n            pollMoreMessages(aws, queueUrl, messages, visibilityTimeout).then(() => {\n                if (progressCallback && messages.length > 0) {\n                    progressCallback(messages.length);\n                }\n            })\n        );\n        await sleep(200);\n    }\n    await Promise.all(promises);\n\n    return messages;\n}\n\nasync function pollMoreMessages(\n    aws: AwsProvider,\n    queueUrl: string,\n    messages: Message[],\n    visibilityTimeout?: number\n): Promise<void> {\n    const messagesResponse = await aws.request<ReceiveMessageRequest, ReceiveMessageResult>(\"SQS\", \"receiveMessage\", {\n        QueueUrl: queueUrl,\n        // 10 is the maximum\n        MaxNumberOfMessages: 10,\n        WaitTimeSeconds: 3,\n        // By default only hide messages for 1 second to avoid disrupting the queue too much\n        VisibilityTimeout: visibilityTimeout ?? 1,\n    });\n    for (const newMessage of messagesResponse.Messages ?? []) {\n        const alreadyInTheList = messages.some((message) => {\n            return message.MessageId === newMessage.MessageId;\n        });\n        if (!alreadyInTheList) {\n            messages.push(newMessage);\n        }\n    }\n}\n\nexport async function retryMessages(\n    aws: AwsProvider,\n    queueUrl: string,\n    dlqUrl: string,\n    messages: Message[]\n): Promise<{\n    numberOfMessagesRetried: number;\n    numberOfMessagesNotRetried: number;\n    numberOfMessagesRetriedButNotDeleted: number;\n}> {\n    if (messages.length === 0) {\n        return {\n            numberOfMessagesRetried: 0,\n            numberOfMessagesNotRetried: 0,\n            numberOfMessagesRetriedButNotDeleted: 0,\n        };\n    }\n\n    const sendBatches = chunk(messages, 10);\n    const sendResults = await Promise.all(\n        sendBatches.map((batch) =>\n            aws.request<SendMessageBatchRequest, SendMessageBatchResult>(\"SQS\", \"sendMessageBatch\", {\n                QueueUrl: queueUrl,\n                Entries: batch.map((message) => {\n                    if (message.MessageId === undefined) {\n                        throw new Error(`Found a message with no ID`);\n                    }\n\n                    return {\n                        Id: message.MessageId,\n                        MessageAttributes: message.MessageAttributes,\n                        MessageBody: message.Body as string,\n                    };\n                }),\n            })\n        )\n    );\n\n    const messagesToDelete = messages.filter((message) => {\n        const isMessageInFailedList = sendResults.some(({ Failed }) =>\n            Failed.some((failedMessage) => message.MessageId === failedMessage.Id)\n        );\n\n        return !isMessageInFailedList;\n    });\n\n    const deleteBatches = chunk(messagesToDelete, 10);\n    const deletionResults = await Promise.all(\n        deleteBatches.map((batch) =>\n            aws.request<DeleteMessageBatchRequest, DeleteMessageBatchResult>(\"SQS\", \"deleteMessageBatch\", {\n                QueueUrl: dlqUrl,\n                Entries: batch.map((message) => {\n                    return {\n                        Id: message.MessageId as string,\n                        ReceiptHandle: message.ReceiptHandle as string,\n                    };\n                }),\n            })\n        )\n    );\n\n    const numberOfMessagesRetried = deletionResults.reduce((total, { Successful }) => total + Successful.length, 0);\n    const numberOfMessagesNotRetried = sendResults.reduce((total, { Failed }) => total + Failed.length, 0);\n    const numberOfMessagesRetriedButNotDeleted = deletionResults.reduce(\n        (total, { Failed }) => total + Failed.length,\n        0\n    );\n\n    if (numberOfMessagesRetriedButNotDeleted > 0) {\n        getUtils().log.warning(\n            `${numberOfMessagesRetriedButNotDeleted} failed messages were not successfully deleted from the dead letter queue. These messages will be retried in the main queue, but they will also still be present in the dead letter queue.`\n        );\n    }\n\n    return {\n        numberOfMessagesRetried,\n        numberOfMessagesNotRetried,\n        numberOfMessagesRetriedButNotDeleted,\n    };\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAUA,oBAAsB;AACtB,mBAAsB;AACtB,oBAAyB;AAIzB,4BAAmC;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,GAMmB;AACnB,QAAM,WAAsB;AAC5B,QAAM,WAAW;AAOjB,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,aAAS,KACL,iBAAiB,KAAK,UAAU,UAAU,mBAAmB,KAAK,MAAM;AACpE,UAAI,oBAAoB,SAAS,SAAS,GAAG;AACzC,yBAAiB,SAAS;AAAA;AAAA;AAItC,UAAM,wBAAM;AAAA;AAEhB,QAAM,QAAQ,IAAI;AAElB,SAAO;AAAA;AAGX,gCACI,KACA,UACA,UACA,mBACa;AAvDjB;AAwDI,QAAM,mBAAmB,MAAM,IAAI,QAAqD,OAAO,kBAAkB;AAAA,IAC7G,UAAU;AAAA,IAEV,qBAAqB;AAAA,IACrB,iBAAiB;AAAA,IAEjB,mBAAmB,gDAAqB;AAAA;AAE5C,aAAW,cAAc,uBAAiB,aAAjB,YAA6B,IAAI;AACtD,UAAM,mBAAmB,SAAS,KAAK,CAAC,YAAY;AAChD,aAAO,QAAQ,cAAc,WAAW;AAAA;AAE5C,QAAI,CAAC,kBAAkB;AACnB,eAAS,KAAK;AAAA;AAAA;AAAA;AAK1B,6BACI,KACA,UACA,QACA,UAKD;AACC,MAAI,SAAS,WAAW,GAAG;AACvB,WAAO;AAAA,MACH,yBAAyB;AAAA,MACzB,4BAA4B;AAAA,MAC5B,sCAAsC;AAAA;AAAA;AAI9C,QAAM,cAAc,yBAAM,UAAU;AACpC,QAAM,cAAc,MAAM,QAAQ,IAC9B,YAAY,IAAI,CAAC,UACb,IAAI,QAAyD,OAAO,oBAAoB;AAAA,IACpF,UAAU;AAAA,IACV,SAAS,MAAM,IAAI,CAAC,YAAY;AAC5B,UAAI,QAAQ,cAAc,QAAW;AACjC,cAAM,IAAI,MAAM;AAAA;AAGpB,aAAO;AAAA,QACH,IAAI,QAAQ;AAAA,QACZ,mBAAmB,QAAQ;AAAA,QAC3B,aAAa,QAAQ;AAAA;AAAA;AAAA;AAOzC,QAAM,mBAAmB,SAAS,OAAO,CAAC,YAAY;AAClD,UAAM,wBAAwB,YAAY,KAAK,CAAC,EAAE,aAC9C,OAAO,KAAK,CAAC,kBAAkB,QAAQ,cAAc,cAAc;AAGvE,WAAO,CAAC;AAAA;AAGZ,QAAM,gBAAgB,yBAAM,kBAAkB;AAC9C,QAAM,kBAAkB,MAAM,QAAQ,IAClC,cAAc,IAAI,CAAC,UACf,IAAI,QAA6D,OAAO,sBAAsB;AAAA,IAC1F,UAAU;AAAA,IACV,SAAS,MAAM,IAAI,CAAC,YAAY;AAC5B,aAAO;AAAA,QACH,IAAI,QAAQ;AAAA,QACZ,eAAe,QAAQ;AAAA;AAAA;AAAA;AAO3C,QAAM,0BAA0B,gBAAgB,OAAO,CAAC,OAAO,EAAE,iBAAiB,QAAQ,WAAW,QAAQ;AAC7G,QAAM,6BAA6B,YAAY,OAAO,CAAC,OAAO,EAAE,aAAa,QAAQ,OAAO,QAAQ;AACpG,QAAM,uCAAuC,gBAAgB,OACzD,CAAC,OAAO,EAAE,aAAa,QAAQ,OAAO,QACtC;AAGJ,MAAI,uCAAuC,GAAG;AAC1C,kCAAW,IAAI,QACX,GAAG;AAAA;AAIX,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA;AAAA;",
  "names": []
}
