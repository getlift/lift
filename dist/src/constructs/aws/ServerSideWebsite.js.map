{
  "version": 3,
  "sources": ["../../../../src/constructs/aws/ServerSideWebsite.ts"],
  "sourcesContent": ["import type { CfnBucket } from \"aws-cdk-lib/aws-s3\";\nimport { Bucket } from \"aws-cdk-lib/aws-s3\";\nimport type { CfnDistribution } from \"aws-cdk-lib/aws-cloudfront\";\nimport {\n    AllowedMethods,\n    CacheCookieBehavior,\n    CacheHeaderBehavior,\n    CachePolicy,\n    CacheQueryStringBehavior,\n    Distribution,\n    FunctionEventType,\n    HttpVersion,\n    OriginProtocolPolicy,\n    OriginRequestCookieBehavior,\n    OriginRequestHeaderBehavior,\n    OriginRequestPolicy,\n    OriginRequestQueryStringBehavior,\n    ViewerProtocolPolicy,\n} from \"aws-cdk-lib/aws-cloudfront\";\nimport type { Construct } from \"constructs\";\nimport type { CfnResource } from \"aws-cdk-lib\";\nimport { CfnOutput, Duration, Fn, RemovalPolicy } from \"aws-cdk-lib\";\nimport type { FromSchema } from \"json-schema-to-ts\";\nimport { HttpOrigin, S3Origin } from \"aws-cdk-lib/aws-cloudfront-origins\";\nimport * as acm from \"aws-cdk-lib/aws-certificatemanager\";\nimport type { BehaviorOptions, ErrorResponse } from \"aws-cdk-lib/aws-cloudfront/lib/distribution\";\nimport * as path from \"path\";\nimport * as fs from \"fs\";\nimport { flatten } from \"lodash\";\nimport * as cloudfront from \"aws-cdk-lib/aws-cloudfront\";\nimport { AwsConstruct } from \"@lift/constructs/abstracts\";\nimport type { ConstructCommands } from \"@lift/constructs\";\nimport type { AwsProvider } from \"@lift/providers\";\nimport { ensureNameMaxLength } from \"../../utils/naming\";\nimport { s3Put, s3Sync } from \"../../utils/s3-sync\";\nimport { emptyBucket, invalidateCloudFrontCache } from \"../../classes/aws\";\nimport ServerlessError from \"../../utils/error\";\nimport { redirectToMainDomain } from \"../../classes/cloudfrontFunctions\";\nimport type { Progress } from \"../../utils/logger\";\nimport { getUtils } from \"../../utils/logger\";\n\nconst SCHEMA = {\n    type: \"object\",\n    properties: {\n        type: { const: \"server-side-website\" },\n        apiGateway: { enum: [\"http\", \"rest\"] },\n        assets: {\n            type: \"object\",\n            additionalProperties: { type: \"string\" },\n            propertyNames: {\n                pattern: \"^/.*$\",\n            },\n            minProperties: 1,\n        },\n        errorPage: { type: \"string\" },\n        domain: {\n            anyOf: [\n                { type: \"string\" },\n                {\n                    type: \"array\",\n                    items: { type: \"string\" },\n                },\n            ],\n        },\n        redirectToMainDomain: { type: \"boolean\" },\n        certificate: { type: \"string\" },\n        forwardedHeaders: { type: \"array\", items: { type: \"string\" } },\n    },\n    additionalProperties: false,\n} as const;\n\ntype Configuration = FromSchema<typeof SCHEMA>;\n\nexport class ServerSideWebsite extends AwsConstruct {\n    public static type = \"server-side-website\";\n    public static schema = SCHEMA;\n    public static commands: ConstructCommands = {\n        \"assets:upload\": {\n            usage: \"Upload assets directly to S3 without going through a CloudFormation deployment.\",\n            handler: ServerSideWebsite.prototype.uploadAssetsCommand,\n        },\n    };\n\n    private readonly distribution: Distribution;\n    private readonly bucket: Bucket;\n    private readonly domains: string[] | undefined;\n    private readonly bucketNameOutput: CfnOutput;\n    private readonly domainOutput: CfnOutput;\n    private readonly cnameOutput: CfnOutput;\n    private readonly distributionIdOutput: CfnOutput;\n\n    constructor(\n        scope: Construct,\n        private readonly id: string,\n        readonly configuration: Configuration,\n        private readonly provider: AwsProvider\n    ) {\n        super(scope, id);\n\n        if (configuration.domain !== undefined && configuration.certificate === undefined) {\n            throw new ServerlessError(\n                `Invalid configuration in 'constructs.${id}.certificate': if a domain is configured, then a certificate ARN must be configured as well.`,\n                \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n            );\n        }\n        if (configuration.errorPage !== undefined && !configuration.errorPage.endsWith(\".html\")) {\n            throw new ServerlessError(\n                `Invalid configuration in 'constructs.${id}.errorPage': the custom error page must be a static HTML file. '${configuration.errorPage}' does not end with '.html'.`,\n                \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n            );\n        }\n\n        this.bucket = new Bucket(this, \"Assets\", {\n            // Assets are compiled artifacts, we can clear them on serverless remove\n            removalPolicy: RemovalPolicy.DESTROY,\n        });\n\n        /**\n         * We create custom \"Origin Policy\" and \"Cache Policy\" for the backend.\n         * \"All URL query strings, HTTP headers, and cookies that you include in the cache key (using a cache policy) are automatically included in origin requests. Use the origin request policy to specify the information that you want to include in origin requests, but not include in the cache key.\"\n         * https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/controlling-origin-requests.html\n         */\n        const backendOriginPolicy = new OriginRequestPolicy(this, \"BackendOriginPolicy\", {\n            originRequestPolicyName: `${this.provider.stackName}-${id}`,\n            comment: `Origin request policy for the ${id} website.`,\n            cookieBehavior: OriginRequestCookieBehavior.all(),\n            queryStringBehavior: OriginRequestQueryStringBehavior.all(),\n            headerBehavior: this.headersToForward(),\n        });\n        const backendCachePolicy = new CachePolicy(this, \"BackendCachePolicy\", {\n            cachePolicyName: `${this.provider.stackName}-${id}`,\n            comment: `Cache policy for the ${id} website.`,\n            // For the backend we disable all caching by default\n            defaultTtl: Duration.seconds(0),\n            // Prevent request collapsing by letting CloudFront understand that requests with\n            // different cookies or query strings are not the same request\n            // https://github.com/getlift/lift/issues/144#issuecomment-1131578142\n            queryStringBehavior: CacheQueryStringBehavior.all(),\n            cookieBehavior: CacheCookieBehavior.all(),\n            // Authorization is an exception and must be whitelisted in the Cache Policy\n            // This is the reason why we don't use the managed `CachePolicy.CACHING_DISABLED`\n            headerBehavior: CacheHeaderBehavior.allowList(\"Authorization\"),\n        });\n\n        const apiId =\n            configuration.apiGateway === \"rest\"\n                ? this.provider.naming.getRestApiLogicalId()\n                : this.provider.naming.getHttpApiLogicalId();\n        const apiGatewayDomain = Fn.join(\".\", [Fn.ref(apiId), `execute-api.${this.provider.region}.amazonaws.com`]);\n\n        // Cast the domains to an array\n        this.domains = configuration.domain !== undefined ? flatten([configuration.domain]) : undefined;\n        const certificate =\n            configuration.certificate !== undefined\n                ? acm.Certificate.fromCertificateArn(this, \"Certificate\", configuration.certificate)\n                : undefined;\n\n        this.distribution = new Distribution(this, \"CDN\", {\n            comment: `${provider.stackName} ${id} website CDN`,\n            defaultBehavior: {\n                // Origins are where CloudFront fetches content\n                origin: new HttpOrigin(apiGatewayDomain, {\n                    // API Gateway only supports HTTPS\n                    protocolPolicy: OriginProtocolPolicy.HTTPS_ONLY,\n                }),\n                // For a backend app we all all methods\n                allowedMethods: AllowedMethods.ALLOW_ALL,\n                cachePolicy: backendCachePolicy,\n                viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,\n                // Forward all values (query strings, headers, and cookies) to the backend app\n                // See https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html#managed-origin-request-policies-list\n                originRequestPolicy: backendOriginPolicy,\n                functionAssociations: [\n                    {\n                        function: this.createRequestFunction(),\n                        eventType: FunctionEventType.VIEWER_REQUEST,\n                    },\n                ],\n            },\n            // All the assets paths are created in there\n            additionalBehaviors: this.createCacheBehaviors(this.bucket),\n            errorResponses: this.createErrorResponses(),\n            // Enable http2 transfer for better performances\n            httpVersion: HttpVersion.HTTP2,\n            certificate: certificate,\n            domainNames: this.domains,\n        });\n\n        // CloudFormation outputs\n        this.bucketNameOutput = new CfnOutput(this, \"AssetsBucketName\", {\n            description: \"Name of the bucket that stores the website assets.\",\n            value: this.bucket.bucketName,\n        });\n        let websiteDomain = this.getMainCustomDomain();\n        if (websiteDomain === undefined) {\n            // Fallback on the CloudFront domain\n            websiteDomain = this.distribution.distributionDomainName;\n        }\n        this.domainOutput = new CfnOutput(this, \"Domain\", {\n            description: \"Website domain name.\",\n            value: websiteDomain,\n        });\n        this.cnameOutput = new CfnOutput(this, \"CloudFrontCName\", {\n            description: \"CloudFront CNAME.\",\n            value: this.distribution.distributionDomainName,\n        });\n        this.distributionIdOutput = new CfnOutput(this, \"DistributionId\", {\n            description: \"ID of the CloudFront distribution.\",\n            value: this.distribution.distributionId,\n        });\n    }\n\n    outputs(): Record<string, () => Promise<string | undefined>> {\n        return {\n            url: () => this.getUrl(),\n            cname: () => this.getCName(),\n        };\n    }\n\n    variables(): Record<string, unknown> {\n        const domain = this.getMainCustomDomain() ?? this.distribution.distributionDomainName;\n\n        return {\n            url: Fn.join(\"\", [\"https://\", domain]),\n            cname: this.distribution.distributionDomainName,\n            assetsBucketName: this.bucket.bucketName,\n        };\n    }\n\n    extend(): Record<string, CfnResource> {\n        return {\n            distribution: this.distribution.node.defaultChild as CfnDistribution,\n            bucket: this.bucket.node.defaultChild as CfnBucket,\n        };\n    }\n\n    async postDeploy(): Promise<void> {\n        await this.uploadAssets();\n    }\n\n    async uploadAssetsCommand(): Promise<void> {\n        getUtils().log(`Deploying the assets for the '${this.id}' website`);\n\n        await this.uploadAssets();\n\n        const domain = await this.getDomain();\n        if (domain !== undefined) {\n            getUtils().log();\n            getUtils().log.success(`Deployed https://${domain}`);\n        }\n    }\n\n    async uploadAssets(): Promise<void> {\n        const bucketName = await this.getBucketName();\n        if (bucketName === undefined) {\n            throw new ServerlessError(\n                `Could not find the bucket in which to deploy the '${this.id}' website: did you forget to run 'serverless deploy' first?`,\n                \"LIFT_MISSING_STACK_OUTPUT\"\n            );\n        }\n\n        const progress = getUtils().progress;\n        let uploadProgress: Progress | undefined;\n        if (progress) {\n            uploadProgress = progress.create();\n        }\n\n        let invalidate = false;\n        for (const [pattern, filePath] of Object.entries(this.getAssetPatterns())) {\n            if (!fs.existsSync(filePath)) {\n                throw new ServerlessError(\n                    `Error in 'constructs.${this.id}': the file or directory '${filePath}' does not exist`,\n                    \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n                );\n            }\n            let s3PathPrefix: string = path.dirname(pattern);\n            if (s3PathPrefix.startsWith(\"/\")) {\n                s3PathPrefix = s3PathPrefix.slice(1);\n            }\n\n            if (fs.lstatSync(filePath).isDirectory()) {\n                // Directory\n                if (uploadProgress) {\n                    uploadProgress.update(`Uploading '${filePath}' to 's3://${bucketName}/${s3PathPrefix}'`);\n                } else {\n                    getUtils().log(`Uploading '${filePath}' to 's3://${bucketName}/${s3PathPrefix}'`);\n                }\n                const { hasChanges } = s3PathPrefix.startsWith(\"upload\")\n                    ? { hasChanges: false }\n                    : await s3Sync({\n                        aws: this.provider,\n                        localPath: filePath,\n                        targetPathPrefix: s3PathPrefix,\n                        bucketName,\n                    });\n                invalidate = invalidate || hasChanges;\n            } else {\n                // File\n                const targetKey = path.posix.join(s3PathPrefix, path.basename(filePath));\n                if (uploadProgress) {\n                    uploadProgress.update(`Uploading '${filePath}' to 's3://${bucketName}/${targetKey}'`);\n                } else {\n                    getUtils().log(`Uploading '${filePath}' to 's3://${bucketName}/${targetKey}'`);\n                }\n                await s3Put(this.provider, bucketName, targetKey, fs.readFileSync(filePath));\n                invalidate = true;\n            }\n        }\n        if (invalidate) {\n            if (uploadProgress) {\n                uploadProgress.update(`Clearing CloudFront DNS cache`);\n            } else {\n                getUtils().log(`Clearing CloudFront DNS cache`);\n            }\n            await this.clearCDNCache();\n        }\n\n        if (uploadProgress) {\n            uploadProgress.remove();\n        }\n    }\n\n    private async clearCDNCache(): Promise<void> {\n        const distributionId = await this.getDistributionId();\n        if (distributionId === undefined) {\n            return;\n        }\n        await invalidateCloudFrontCache(this.provider, distributionId);\n    }\n\n    async preRemove(): Promise<void> {\n        const bucketName = await this.getBucketName();\n        if (bucketName === undefined) {\n            // No bucket found => nothing to delete!\n            return;\n        }\n\n        getUtils().log(\n            `Emptying S3 bucket '${bucketName}' for the '${this.id}' website, else CloudFormation will fail (it cannot delete a non-empty bucket)`\n        );\n        await emptyBucket(this.provider, bucketName);\n    }\n\n    async getUrl(): Promise<string | undefined> {\n        const domain = await this.getDomain();\n        if (domain === undefined) {\n            return undefined;\n        }\n\n        return `https://${domain}`;\n    }\n\n    async getBucketName(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.bucketNameOutput);\n    }\n\n    async getDomain(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.domainOutput);\n    }\n\n    async getCName(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.cnameOutput);\n    }\n\n    async getDistributionId(): Promise<string | undefined> {\n        return this.provider.getStackOutput(this.distributionIdOutput);\n    }\n\n    getMainCustomDomain(): string | undefined {\n        if (this.configuration.domain === undefined) {\n            return undefined;\n        }\n\n        // In case of multiple domains, we take the first one\n        return typeof this.configuration.domain === \"string\" ? this.configuration.domain : this.configuration.domain[0];\n    }\n\n    private headersToForward(): OriginRequestHeaderBehavior {\n        let additionalHeadersToForward = this.configuration.forwardedHeaders ?? [];\n        if (additionalHeadersToForward.includes(\"Host\")) {\n            throw new ServerlessError(\n                `Invalid value in 'constructs.${this.id}.forwardedHeaders': the 'Host' header cannot be forwarded (this is an API Gateway limitation). Use the 'X-Forwarded-Host' header in your code instead (it contains the value of the original 'Host' header).`,\n                \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n            );\n        }\n        // `Authorization` cannot be forwarded via this setting (we automatically forward it anyway so we remove it from the list)\n        additionalHeadersToForward = additionalHeadersToForward.filter((header: string) => header !== \"Authorization\");\n        if (additionalHeadersToForward.length > 0) {\n            if (additionalHeadersToForward.length > 10) {\n                throw new ServerlessError(\n                    `Invalid value in 'constructs.${this.id}.forwardedHeaders': ${additionalHeadersToForward.length} headers are configured but only 10 headers can be forwarded (this is an CloudFront limitation).`,\n                    \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n                );\n            }\n\n            // Custom list\n            return OriginRequestHeaderBehavior.allowList(...additionalHeadersToForward);\n        }\n\n        /**\n         * We forward everything except:\n         * - `Host` because it messes up API Gateway (that uses the Host to identify which API Gateway to invoke)\n         * - `Authorization` because it must be configured on the cache policy\n         *   (see https://aws.amazon.com/premiumsupport/knowledge-center/cloudfront-authorization-header/?nc1=h_ls)\n         */\n        return OriginRequestHeaderBehavior.allowList(\n            \"Accept\",\n            \"Accept-Language\",\n            \"Content-Type\",\n            \"Origin\",\n            \"Referer\",\n            \"User-Agent\",\n            \"X-Requested-With\",\n            // This header is set by our CloudFront Function\n            \"X-Forwarded-Host\"\n        );\n    }\n\n    private createCacheBehaviors(bucket: Bucket): Record<string, BehaviorOptions> {\n        const behaviors: Record<string, BehaviorOptions> = {};\n        for (const pattern of Object.keys(this.getAssetPatterns())) {\n            if (pattern === \"/\" || pattern === \"/*\") {\n                throw new ServerlessError(\n                    `Invalid key in 'constructs.${this.id}.assets': '/' and '/*' cannot be routed to assets because the root URL already serves the backend application running in Lambda. You must use a sub-path instead, for example '/assets/*'.`,\n                    \"LIFT_INVALID_CONSTRUCT_CONFIGURATION\"\n                );\n            }\n            behaviors[pattern] = {\n                // Origins are where CloudFront fetches content\n                origin: new S3Origin(bucket),\n                allowedMethods: AllowedMethods.ALLOW_GET_HEAD_OPTIONS,\n                // Use the \"Managed-CachingOptimized\" policy\n                // See https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html#managed-cache-policies-list\n                cachePolicy: CachePolicy.CACHING_OPTIMIZED,\n                viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,\n            };\n        }\n\n        return behaviors;\n    }\n\n    private createRequestFunction(): cloudfront.Function {\n        let additionalCode = \"\";\n\n        if (this.configuration.redirectToMainDomain === true) {\n            additionalCode += redirectToMainDomain(this.domains);\n        }\n\n        /**\n         * CloudFront function that forwards the real `Host` header into `X-Forwarded-Host`\n         *\n         * CloudFront does not forward the original `Host` header. We use this\n         * to forward the website domain name to the backend app via the `X-Forwarded-Host` header.\n         * Learn more: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host\n         */\n        const code = `function handler(event) {\n    var request = event.request;\n    request.headers[\"x-forwarded-host\"] = request.headers[\"host\"];${additionalCode}\n    return request;\n}`;\n\n        const functionName = ensureNameMaxLength(\n            `${this.provider.stackName}-${this.provider.region}-${this.id}-request`,\n            64\n        );\n\n        return new cloudfront.Function(this, \"RequestFunction\", {\n            functionName,\n            code: cloudfront.FunctionCode.fromInline(code),\n        });\n    }\n\n    private createErrorResponses(): ErrorResponse[] {\n        let responsePagePath = undefined;\n        if (this.configuration.errorPage !== undefined) {\n            responsePagePath = `/${this.getErrorPageFileName()}`;\n        }\n\n        return [\n            {\n                httpStatus: 500,\n                // Disable caching of error responses\n                ttl: Duration.seconds(0),\n                responsePagePath,\n            },\n            {\n                httpStatus: 504,\n                // Disable caching of error responses\n                ttl: Duration.seconds(0),\n                responsePagePath,\n            },\n        ];\n    }\n\n    private getAssetPatterns(): Record<string, string> {\n        const assetPatterns = this.configuration.assets ?? {};\n        // If a custom error page is provided, we upload it to S3\n        if (this.configuration.errorPage !== undefined) {\n            assetPatterns[`/${this.getErrorPageFileName()}`] = this.configuration.errorPage;\n        }\n\n        return assetPatterns;\n    }\n\n    private getErrorPageFileName(): string {\n        return this.configuration.errorPage !== undefined ? path.basename(this.configuration.errorPage) : \"\";\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
