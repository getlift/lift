{
  "version": 3,
  "sources": ["../../../../src/constructs/abstracts/AwsConstruct.ts"],
  "sourcesContent": ["import { Construct as CdkConstruct } from \"constructs\";\nimport type { AwsProvider } from \"@lift/providers\";\nimport type { ConstructInterface } from \"@lift/constructs\";\nimport { get, isArray, isEmpty, isObject } from \"lodash\";\nimport { paths } from \"traverse\";\nimport type { CfnResource } from \"aws-cdk-lib\";\nimport ServerlessError from \"../../utils/error\";\n\nexport abstract class AwsConstruct extends CdkConstruct implements ConstructInterface {\n    private applyExtensions(extensions: Record<string, unknown>) {\n        const availableExtensions = this.extend();\n        if (isEmpty(extensions) || isEmpty(availableExtensions)) {\n            return;\n        }\n        Object.entries(extensions).forEach(([extensionKey, extensionObject]) => {\n            if (!Object.keys(availableExtensions).includes(extensionKey)) {\n                throw new ServerlessError(\n                    `There is no extension '${extensionKey}' available on this construct. Available extensions are: ${Object.keys(\n                        availableExtensions\n                    ).join(\", \")}.`,\n                    \"LIFT_UNKNOWN_EXTENSION\"\n                );\n            }\n            if (isObject(extensionObject)) {\n                const accumulatedPathsPointingToArray: string[] = [];\n                paths(extensionObject)\n                    .filter((path) => !isEmpty(path))\n                    .map((path) => {\n                        return path.join(\".\");\n                    })\n                    .filter((path) => {\n                        if (\n                            accumulatedPathsPointingToArray.some((previouslySelectedPath) =>\n                                path.startsWith(previouslySelectedPath)\n                            )\n                        ) {\n                            return false;\n                        }\n\n                        const pointedValue: unknown = get(extensionObject, path);\n                        const isPathPointingToArray = isArray(pointedValue);\n                        if (isPathPointingToArray) {\n                            accumulatedPathsPointingToArray.push(path);\n\n                            return true;\n                        }\n\n                        const isPathPointingToLeaf = !isObject(pointedValue);\n\n                        return isPathPointingToLeaf;\n                    })\n                    .map((path) => {\n                        availableExtensions[extensionKey].addOverride(path, get(extensionObject, path));\n                    });\n            }\n        });\n    }\n\n    static create<C extends AwsConstruct = AwsConstruct>(\n        this: {\n            new (\n                scope: CdkConstruct,\n                id: string,\n                configuration: { extensions?: Record<string, unknown> } & Record<string, unknown>,\n                provider: AwsProvider\n            ): C;\n        },\n        provider: AwsProvider,\n        id: string,\n        configuration: { extensions?: Record<string, unknown> } & Record<string, unknown>\n    ): C {\n        /**\n         * We are passing a `configuration` of type `Record<string, unknown>` to a parameter\n         * of stricter type. This is theoretically invalid.\n         *\n         * In practice however, `configuration` has been validated with the exact JSON schema\n         * of the construct. And that construct has generated the type for `configuration` based\n         * on that schema.\n         * As such, we _know_ that `configuration` has the correct type, it is just not validated\n         * by TypeScript's compiler.\n         */\n        const construct = new this(provider.stack, id, configuration, provider);\n        construct.applyExtensions(configuration.extensions ?? {});\n\n        return construct;\n    }\n\n    abstract outputs?(): Record<string, () => Promise<string | undefined>>;\n\n    abstract extend(): Record<string, CfnResource>;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,wBAA0C;AAG1C,oBAAgD;AAChD,sBAAsB;AAEtB,mBAA4B;AAErB,2BAAoC,4BAA2C;AAAA,EAC1E,gBAAgB,YAAqC;AACzD,UAAM,sBAAsB,KAAK;AACjC,QAAI,2BAAQ,eAAe,2BAAQ,sBAAsB;AACrD;AAAA;AAEJ,WAAO,QAAQ,YAAY,QAAQ,CAAC,CAAC,cAAc,qBAAqB;AACpE,UAAI,CAAC,OAAO,KAAK,qBAAqB,SAAS,eAAe;AAC1D,cAAM,IAAI,qBACN,0BAA0B,wEAAwE,OAAO,KACrG,qBACF,KAAK,UACP;AAAA;AAGR,UAAI,4BAAS,kBAAkB;AAC3B,cAAM,kCAA4C;AAClD,mCAAM,iBACD,OAAO,CAAC,SAAS,CAAC,2BAAQ,OAC1B,IAAI,CAAC,SAAS;AACX,iBAAO,KAAK,KAAK;AAAA,WAEpB,OAAO,CAAC,SAAS;AACd,cACI,gCAAgC,KAAK,CAAC,2BAClC,KAAK,WAAW,0BAEtB;AACE,mBAAO;AAAA;AAGX,gBAAM,eAAwB,uBAAI,iBAAiB;AACnD,gBAAM,wBAAwB,2BAAQ;AACtC,cAAI,uBAAuB;AACvB,4CAAgC,KAAK;AAErC,mBAAO;AAAA;AAGX,gBAAM,uBAAuB,CAAC,4BAAS;AAEvC,iBAAO;AAAA,WAEV,IAAI,CAAC,SAAS;AACX,8BAAoB,cAAc,YAAY,MAAM,uBAAI,iBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA,SAMtF,OASH,UACA,IACA,eACC;AAtET;AAiFQ,UAAM,YAAY,IAAI,KAAK,SAAS,OAAO,IAAI,eAAe;AAC9D,cAAU,gBAAgB,oBAAc,eAAd,YAA4B;AAEtD,WAAO;AAAA;AAAA;",
  "names": []
}
