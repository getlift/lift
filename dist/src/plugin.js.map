{
  "version": 3,
  "sources": ["../../src/plugin.ts"],
  "sourcesContent": ["import { flatten, get, has, merge } from \"lodash\";\nimport type { AwsIamPolicyStatements } from \"@serverless/typescript\";\nimport * as path from \"path\";\nimport { readFileSync } from \"fs\";\nimport { dump } from \"js-yaml\";\nimport { DefaultTokenResolver, Lazy, StringConcat, Tokenization } from \"aws-cdk-lib\";\nimport type { FromSchema } from \"json-schema-to-ts\";\nimport type { ProviderInterface, StaticProviderInterface } from \"@lift/providers\";\nimport { AwsProvider, StripeProvider } from \"@lift/providers\";\nimport type { ConstructInterface, StaticConstructInterface } from \"@lift/constructs\";\nimport chalk from \"chalk\";\nimport type {\n    CommandsDefinition,\n    DeprecatedVariableResolver,\n    Hook,\n    Serverless,\n    VariableResolver,\n} from \"./types/serverless\";\nimport type { ServerlessUtils } from \"./utils/logger\";\nimport { getUtils, setUtils } from \"./utils/logger\";\nimport ServerlessError from \"./utils/error\";\n\nconst PROVIDER_ID_PATTERN = \"^[a-zA-Z0-9-_]+$\";\n// This enables all existing constructs defined prior intoduction of \"providers\" property to work\nconst DEFAULT_PROVIDER = \"defaultAwsProvider\";\nconst PROVIDERS_DEFINITION = {\n    type: \"object\",\n    patternProperties: {\n        [PROVIDER_ID_PATTERN]: {\n            allOf: [\n                {\n                    type: \"object\",\n                    properties: {\n                        type: { type: \"string\" },\n                    },\n                    required: [\"type\"],\n                },\n            ] as Record<string, unknown>[],\n        },\n    },\n    additionalProperties: false,\n};\n\nconst CONSTRUCT_ID_PATTERN = \"^[a-zA-Z0-9-_]+$\";\nconst CONSTRUCTS_DEFINITION = {\n    type: \"object\",\n    patternProperties: {\n        [CONSTRUCT_ID_PATTERN]: {\n            allOf: [\n                {\n                    type: \"object\",\n                    properties: {\n                        type: { type: \"string\" },\n                        provider: { type: \"string\" },\n                        extensions: { type: \"object\" },\n                    },\n                    required: [\"type\"],\n                },\n            ],\n        },\n    },\n    additionalProperties: false,\n} as const;\n\nconst LIFT_CONFIG_SCHEMA = {\n    type: \"object\",\n    properties: {\n        automaticPermissions: { type: \"boolean\" },\n    },\n    additionalProperties: false,\n} as const;\ntype LiftConfig = FromSchema<typeof LIFT_CONFIG_SCHEMA>;\n\n/**\n * Serverless plugin\n */\nclass LiftPlugin {\n    private constructs?: Record<string, ConstructInterface>;\n    private providers: Record<string, ProviderInterface>;\n    private readonly serverless: Serverless;\n    private static readonly providerClasses: Record<string, StaticProviderInterface> = {};\n    private readonly providersSchema = PROVIDERS_DEFINITION;\n    private readonly constructsSchema = CONSTRUCTS_DEFINITION;\n    public readonly hooks: Record<string, Hook>;\n    public readonly commands: CommandsDefinition = {};\n    public readonly configurationVariablesSources: Record<string, VariableResolver>;\n    public readonly variableResolvers: Record<string, DeprecatedVariableResolver>;\n    private readonly cliOptions: Record<string, string>;\n\n    constructor(serverless: Serverless, cliOptions: Record<string, string>, utils?: ServerlessUtils) {\n        this.serverless = serverless;\n        setUtils(utils);\n\n        // This method is exposed for Lift tests only, it is not a public API\n        Object.assign(this.serverless, { getLiftProviderById: this.getLiftProviderById.bind(this) });\n        this.cliOptions = cliOptions;\n\n        this.commands.lift = {\n            commands: {\n                eject: {\n                    usage: \"Eject Lift constructs to raw CloudFormation\",\n                    lifecycleEvents: [\"eject\"],\n                },\n            },\n        };\n\n        this.hooks = {\n            initialize: () => {\n                this.loadConstructs();\n                this.appendPermissions();\n                this.resolveLazyVariables();\n            },\n            \"before:aws:info:displayStackOutputs\": this.info.bind(this),\n            \"after:package:compileEvents\": this.appendCloudformationResources.bind(this),\n            \"after:deploy:deploy\": this.postDeploy.bind(this),\n            \"before:remove:remove\": this.preRemove.bind(this),\n            \"lift:eject:eject\": this.eject.bind(this),\n        };\n\n        this.configurationVariablesSources = {\n            construct: {\n                resolve: this.resolveReference.bind(this),\n            },\n        };\n        this.variableResolvers = {\n            construct: (fullVariable) => {\n                const address = fullVariable.split(\":\")[1];\n\n                return Promise.resolve(this.resolveReference({ address }).value);\n            },\n        };\n\n        this.providers = { [DEFAULT_PROVIDER]: new AwsProvider(this.serverless) };\n        this.loadProviders();\n        this.registerConstructsSchema();\n        this.registerProvidersSchema();\n        this.registerConfigSchema();\n        this.registerCommands();\n    }\n\n    private registerConstructsSchema() {\n        (\n            this.constructsSchema.patternProperties[CONSTRUCT_ID_PATTERN].allOf as unknown as Record<string, unknown>[]\n        ).push({\n            oneOf: this.getAllConstructClasses().map((Construct) => {\n                return merge(this.defineSchemaWithType(Construct.type, Construct.schema), {\n                    properties: { extensions: { type: \"object\" } },\n                });\n            }),\n        });\n    }\n\n    private registerProvidersSchema() {\n        this.providersSchema.patternProperties[PROVIDER_ID_PATTERN].allOf.push({\n            oneOf: LiftPlugin.getAllProviderClasses().map((Provider) => {\n                return this.defineSchemaWithType(Provider.type, Provider.schema);\n            }),\n        });\n    }\n\n    private defineSchemaWithType(type: string, configSchema: Record<string, unknown>): Record<string, unknown> {\n        return merge({}, configSchema, { properties: { type: { const: type } } });\n    }\n\n    private registerConfigSchema() {\n        this.serverless.configSchemaHandler.defineTopLevelProperty(\"lift\", LIFT_CONFIG_SCHEMA);\n        this.serverless.configSchemaHandler.defineTopLevelProperty(\"constructs\", this.constructsSchema);\n        this.serverless.configSchemaHandler.defineTopLevelProperty(\"providers\", this.providersSchema);\n    }\n\n    static registerProviders(...providerClasses: StaticProviderInterface[]): void {\n        for (const providerClass of providerClasses) {\n            if (providerClass.type in this.providerClasses) {\n                throw new ServerlessError(\n                    `The provider type '${providerClass.type}' was registered twice`,\n                    \"LIFT_PROVIDER_TYPE_CONFLICT\"\n                );\n            }\n            this.providerClasses[providerClass.type] = providerClass;\n        }\n    }\n\n    static getProviderClass(type: string): StaticProviderInterface | undefined {\n        return this.providerClasses[type];\n    }\n\n    static getAllProviderClasses(): StaticProviderInterface[] {\n        return Object.values(this.providerClasses);\n    }\n\n    private loadProviders() {\n        const providersInputConfiguration = get(this.serverless.configurationInput, \"providers\", {});\n        for (const [id, { type }] of Object.entries(providersInputConfiguration)) {\n            this.providers[id] = this.createProvider(type, id);\n        }\n    }\n\n    private createProvider(type: string, id: string): ProviderInterface {\n        if (type === AwsProvider.type) {\n            throw new ServerlessError(\n                \"AwsProvider is not configurable via providers\",\n                \"LIFT_AWS_PROVIDER_CONFIGURATION\"\n            );\n        }\n        const Provider = LiftPlugin.getProviderClass(type);\n        if (Provider === undefined) {\n            throw new ServerlessError(\n                `The provider '${id}' has an unknown type '${type}'`,\n                \"LIFT_UNKNOWN_PROVIDER_TYPE\"\n            );\n        }\n        const configuration = get(this.serverless.configurationInput.providers, id, {});\n\n        return Provider.create(this.serverless, id, configuration);\n    }\n\n    private loadConstructs(): void {\n        if (this.constructs !== undefined) {\n            // Safeguard\n            throw new Error(\"Constructs are already initialized: this should not happen\");\n        }\n        this.constructs = {};\n        const constructsInputConfiguration = get(this.serverless.configurationInput, \"constructs\", {});\n        for (const [id, { type, provider: providerId }] of Object.entries(constructsInputConfiguration)) {\n            // Legacy behavior -> defaults to Serverless framework AWS provider\n            if (providerId === undefined) {\n                this.constructs[id] = this.providers[DEFAULT_PROVIDER].createConstruct(type, id);\n                continue;\n            }\n            const provider = this.getLiftProviderById(providerId);\n            if (!provider) {\n                throw new ServerlessError(\n                    `No provider ${providerId} was found for construct ${id}. Available providers are ${Object.keys(\n                        this.providers\n                    ).join(\", \")}`,\n                    \"LIFT_UNKNOWN_PROVIDER_ID\"\n                );\n            }\n            this.constructs[id] = provider.createConstruct(type, id);\n        }\n    }\n\n    private getConstructs(): Record<string, ConstructInterface> {\n        if (this.constructs === undefined) {\n            // Safeguard\n            throw new Error(\"Constructs are not initialized: this should not happen\");\n        }\n\n        return this.constructs;\n    }\n\n    getLiftProviderById(id: string): ProviderInterface | undefined {\n        return this.providers[id];\n    }\n\n    resolveReference({ address }: { address: string }): { value: string } {\n        return {\n            /**\n             * Construct variables are resolved lazily using the CDK's \"Token\" system.\n             * CDK Lazy values generate a unique `${Token[TOKEN.63]}` string. These strings\n             * can later be resolved to the real value (which we do in `initialize()`).\n             * Problem:\n             * - Lift variables need constructs to be resolved\n             * - Constructs can be created when Serverless variables are resolved\n             * - Serverless variables must resolve Lift variables\n             * This is a chicken and egg problem.\n             * Solution:\n             * - Serverless boots, plugins are created\n             * - variables are resolved\n             *   - Lift variables are resolved to CDK tokens (`${Token[TOKEN.63]}`) via `Lazy.any(...)`\n             *     (we can't resolve the actual values since we don't have the constructs yet)\n             * - `initialize` hook\n             *   - Lift builds the constructs\n             *   - CDK tokens are resolved into real value: we can now do that using the CDK \"token resolver\"\n             */\n            value: Lazy.any({\n                produce: () => {\n                    const constructs = this.getConstructs();\n                    const [id, property] = address.split(\".\", 2);\n                    if (!has(this.constructs, id)) {\n                        throw new ServerlessError(\n                            `No construct named '${id}' was found, the \\${construct:${id}.${property}} variable is invalid.`,\n                            \"LIFT_VARIABLE_UNKNOWN_CONSTRUCT\"\n                        );\n                    }\n                    const construct = constructs[id];\n\n                    const properties = construct.variables ? construct.variables() : {};\n                    if (!has(properties, property)) {\n                        if (Object.keys(properties).length === 0) {\n                            throw new ServerlessError(\n                                `\\${construct:${id}.${property}} does not exist. The construct '${id}' does not expose any property`,\n                                \"LIFT_VARIABLE_UNKNOWN_PROPERTY\"\n                            );\n                        }\n                        throw new ServerlessError(\n                            `\\${construct:${id}.${property}} does not exist. Properties available on \\${construct:${id}} are: ${Object.keys(\n                                properties\n                            ).join(\", \")}`,\n                            \"LIFT_VARIABLE_UNKNOWN_PROPERTY\"\n                        );\n                    }\n\n                    return properties[property];\n                },\n            }).toString(),\n        };\n    }\n\n    async info(): Promise<void> {\n        const constructs = this.getConstructs();\n        for (const [id, construct] of Object.entries(constructs)) {\n            if (typeof construct.outputs !== \"function\") {\n                continue;\n            }\n            const outputs = construct.outputs();\n            if (Object.keys(outputs).length === 1) {\n                const resolver = Object.values(outputs)[0];\n                const output = await resolver();\n                if (output !== undefined) {\n                    if (this.serverless.addServiceOutputSection) {\n                        this.serverless.addServiceOutputSection(id, output);\n                    } else {\n                        console.log(`${chalk.yellow(`${id}:`)} ${output}`);\n                    }\n                }\n            }\n            if (Object.keys(outputs).length > 1) {\n                const content: string[] = [];\n                for (const [name, resolver] of Object.entries(outputs)) {\n                    const output = await resolver();\n                    if (output !== undefined) {\n                        content.push(`${name}: ${output}`);\n                    }\n                }\n                if (this.serverless.addServiceOutputSection) {\n                    this.serverless.addServiceOutputSection(id, content);\n                } else {\n                    console.log(chalk.yellow(`${id}:`));\n                    console.log(content.map((line) => `  ${line}`).join(`\\n`));\n                }\n            }\n        }\n    }\n\n    private registerCommands() {\n        const constructsConfiguration = get(this.serverless.configurationInput, \"constructs\", {}) as Record<\n            string,\n            { type?: string }\n        >;\n        // For each construct\n        for (const [id, constructConfig] of Object.entries(constructsConfiguration)) {\n            if (constructConfig.type === undefined) {\n                throw new ServerlessError(\n                    `The construct '${id}' has no 'type' defined.\\n` +\n                        \"Find all construct types available here: https://github.com/getlift/lift#constructs\",\n                    \"LIFT_MISSING_CONSTRUCT_TYPE\"\n                );\n            }\n            const constructClass = this.getConstructClass(constructConfig.type);\n            if (constructClass === undefined) {\n                throw new ServerlessError(\n                    `The construct '${id}' has an unknown type '${constructConfig.type}'\\n` +\n                        \"Find all construct types available here: https://github.com/getlift/lift#constructs\",\n                    \"LIFT_UNKNOWN_CONSTRUCT_TYPE\"\n                );\n            }\n            if (constructClass.commands === undefined) {\n                continue;\n            }\n            // For each command of the construct\n            for (const [command, commandDefinition] of Object.entries(constructClass.commands)) {\n                this.commands[`${id}:${command}`] = {\n                    lifecycleEvents: [command],\n                    usage: commandDefinition.usage,\n                    options: commandDefinition.options,\n                };\n                // Register the command handler\n                this.hooks[`${id}:${command}:${command}`] = () => {\n                    // We resolve the construct instance on the fly\n                    const construct = this.getConstructs()[id];\n\n                    return commandDefinition.handler.call(construct, this.cliOptions);\n                };\n            }\n        }\n    }\n\n    private async postDeploy(): Promise<void> {\n        const constructs = this.getConstructs();\n        for (const [, construct] of Object.entries(constructs)) {\n            if (construct.postDeploy !== undefined) {\n                await construct.postDeploy();\n            }\n        }\n    }\n\n    private async preRemove(): Promise<void> {\n        const constructs = this.getConstructs();\n        for (const [, construct] of Object.entries(constructs)) {\n            if (construct.preRemove !== undefined) {\n                await construct.preRemove();\n            }\n        }\n    }\n\n    private resolveLazyVariables() {\n        // Use the CDK token resolver to resolve all lazy variables in the template\n        const tokenResolver = new DefaultTokenResolver(new StringConcat());\n        const resolveTokens = <T>(input: T): T => {\n            if (input === undefined) {\n                return input;\n            }\n\n            return Tokenization.resolve(input, {\n                resolver: tokenResolver,\n                scope: (this.providers[DEFAULT_PROVIDER] as AwsProvider).stack,\n            }) as T;\n        };\n        this.serverless.service.provider = resolveTokens(this.serverless.service.provider);\n        this.serverless.service.package = resolveTokens(this.serverless.service.package);\n        this.serverless.service.custom = resolveTokens(this.serverless.service.custom);\n        this.serverless.service.resources = resolveTokens(this.serverless.service.resources);\n        this.serverless.service.functions = resolveTokens(this.serverless.service.functions);\n        this.serverless.service.layers = resolveTokens(this.serverless.service.layers);\n        this.serverless.service.outputs = resolveTokens(this.serverless.service.outputs);\n        // Also resolve tokens in `configurationInput` because they also appear in there\n        this.serverless.configurationInput = resolveTokens(this.serverless.configurationInput);\n    }\n\n    // This is only required for AwsProvider in order to bundle resources together with existing SLS framework resources\n    private appendCloudformationResources() {\n        (this.providers[DEFAULT_PROVIDER] as AwsProvider).appendCloudformationResources();\n    }\n\n    private appendPermissions(): void {\n        // Automatic permissions can be disabled via a `lift.automaticPermissions` flag in serverless.yml\n        const liftConfiguration = get(this.serverless.configurationInput, \"lift\", {}) as LiftConfig;\n        if (liftConfiguration.automaticPermissions === false) {\n            return;\n        }\n\n        const constructs = this.getConstructs();\n        const statements = flatten(\n            Object.entries(constructs).map(([, construct]) => {\n                return (construct.permissions ? construct.permissions() : []) as unknown as AwsIamPolicyStatements;\n            })\n        );\n        if (statements.length === 0) {\n            return;\n        }\n\n        const role = this.serverless.service.provider.iam?.role;\n\n        if (typeof role === \"object\" && \"statements\" in role) {\n            role.statements?.push(...statements);\n\n            return;\n        }\n\n        this.serverless.service.provider.iamRoleStatements = this.serverless.service.provider.iamRoleStatements ?? [];\n        this.serverless.service.provider.iamRoleStatements.push(...statements);\n    }\n\n    private async eject() {\n        getUtils().log(\"Ejecting from Lift to CloudFormation\");\n        getUtils().log();\n        await this.serverless.pluginManager.spawn(\"package\");\n        const legacyProvider = this.serverless.getProvider(\"aws\");\n        const compiledTemplateFileName = legacyProvider.naming.getCompiledTemplateFileName();\n        const compiledTemplateFilePath = path.join(this.serverless.serviceDir, \".serverless\", compiledTemplateFileName);\n        const cfTemplate = readFileSync(compiledTemplateFilePath);\n        const formattedYaml = dump(JSON.parse(cfTemplate.toString()));\n        getUtils().writeText(formattedYaml);\n        getUtils().log(\"You can also find that CloudFormation template in the following file:\");\n        getUtils().log(compiledTemplateFilePath);\n    }\n\n    private getAllConstructClasses(): StaticConstructInterface[] {\n        const result = flatten(\n            LiftPlugin.getAllProviderClasses().map((providerClass) => providerClass.getAllConstructClasses())\n        );\n\n        return result;\n    }\n\n    private getConstructClass(constructType: string): StaticConstructInterface | undefined {\n        for (const providerClass of LiftPlugin.getAllProviderClasses()) {\n            const constructClass = providerClass.getConstructClass(constructType);\n            if (constructClass !== undefined) {\n                return constructClass;\n            }\n        }\n\n        return undefined;\n    }\n}\n\nexport type Lift = Partial<{\n    constructs: FromSchema<typeof CONSTRUCTS_DEFINITION>;\n    lift: FromSchema<typeof LIFT_CONFIG_SCHEMA>;\n}>;\n\nLiftPlugin.registerProviders(AwsProvider, StripeProvider);\n\nmodule.exports = LiftPlugin;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA,oBAAyC;AAEzC,WAAsB;AACtB,gBAA6B;AAC7B,qBAAqB;AACrB,yBAAuE;AAGvE,uBAA4C;AAE5C,mBAAkB;AASlB,oBAAmC;AACnC,mBAA4B;AAE5B,MAAM,sBAAsB;AAE5B,MAAM,mBAAmB;AACzB,MAAM,uBAAuB;AAAA,EACzB,MAAM;AAAA,EACN,mBAAmB;AAAA,KACd,sBAAsB;AAAA,MACnB,OAAO;AAAA,QACH;AAAA,UACI,MAAM;AAAA,UACN,YAAY;AAAA,YACR,MAAM,EAAE,MAAM;AAAA;AAAA,UAElB,UAAU,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAK3B,sBAAsB;AAAA;AAG1B,MAAM,uBAAuB;AAC7B,MAAM,wBAAwB;AAAA,EAC1B,MAAM;AAAA,EACN,mBAAmB;AAAA,KACd,uBAAuB;AAAA,MACpB,OAAO;AAAA,QACH;AAAA,UACI,MAAM;AAAA,UACN,YAAY;AAAA,YACR,MAAM,EAAE,MAAM;AAAA,YACd,UAAU,EAAE,MAAM;AAAA,YAClB,YAAY,EAAE,MAAM;AAAA;AAAA,UAExB,UAAU,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAK3B,sBAAsB;AAAA;AAG1B,MAAM,qBAAqB;AAAA,EACvB,MAAM;AAAA,EACN,YAAY;AAAA,IACR,sBAAsB,EAAE,MAAM;AAAA;AAAA,EAElC,sBAAsB;AAAA;AAO1B,0BAAiB;AAAA,EAab,YAAY,YAAwB,YAAoC,OAAyB;AARhF,2BAAkB;AAClB,4BAAmB;AAEpB,oBAA+B;AAM3C,SAAK,aAAa;AAClB,gCAAS;AAGT,WAAO,OAAO,KAAK,YAAY,EAAE,qBAAqB,KAAK,oBAAoB,KAAK;AACpF,SAAK,aAAa;AAElB,SAAK,SAAS,OAAO;AAAA,MACjB,UAAU;AAAA,QACN,OAAO;AAAA,UACH,OAAO;AAAA,UACP,iBAAiB,CAAC;AAAA;AAAA;AAAA;AAK9B,SAAK,QAAQ;AAAA,MACT,YAAY,MAAM;AACd,aAAK;AACL,aAAK;AACL,aAAK;AAAA;AAAA,MAET,uCAAuC,KAAK,KAAK,KAAK;AAAA,MACtD,+BAA+B,KAAK,8BAA8B,KAAK;AAAA,MACvE,uBAAuB,KAAK,WAAW,KAAK;AAAA,MAC5C,wBAAwB,KAAK,UAAU,KAAK;AAAA,MAC5C,oBAAoB,KAAK,MAAM,KAAK;AAAA;AAGxC,SAAK,gCAAgC;AAAA,MACjC,WAAW;AAAA,QACP,SAAS,KAAK,iBAAiB,KAAK;AAAA;AAAA;AAG5C,SAAK,oBAAoB;AAAA,MACrB,WAAW,CAAC,iBAAiB;AACzB,cAAM,UAAU,aAAa,MAAM,KAAK;AAExC,eAAO,QAAQ,QAAQ,KAAK,iBAAiB,EAAE,WAAW;AAAA;AAAA;AAIlE,SAAK,YAAY,GAAG,mBAAmB,IAAI,6BAAY,KAAK;AAC5D,SAAK;AACL,SAAK;AACL,SAAK;AACL,SAAK;AACL,SAAK;AAAA;AAAA,EAGD,2BAA2B;AAC/B,IACI,KAAK,iBAAiB,kBAAkB,sBAAsB,MAChE,KAAK;AAAA,MACH,OAAO,KAAK,yBAAyB,IAAI,CAAC,cAAc;AACpD,eAAO,yBAAM,KAAK,qBAAqB,UAAU,MAAM,UAAU,SAAS;AAAA,UACtE,YAAY,EAAE,YAAY,EAAE,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA,EAM1C,0BAA0B;AAC9B,SAAK,gBAAgB,kBAAkB,qBAAqB,MAAM,KAAK;AAAA,MACnE,OAAO,YAAW,wBAAwB,IAAI,CAAC,aAAa;AACxD,eAAO,KAAK,qBAAqB,SAAS,MAAM,SAAS;AAAA;AAAA;AAAA;AAAA,EAK7D,qBAAqB,MAAc,cAAgE;AACvG,WAAO,yBAAM,IAAI,cAAc,EAAE,YAAY,EAAE,MAAM,EAAE,OAAO;AAAA;AAAA,EAG1D,uBAAuB;AAC3B,SAAK,WAAW,oBAAoB,uBAAuB,QAAQ;AACnE,SAAK,WAAW,oBAAoB,uBAAuB,cAAc,KAAK;AAC9E,SAAK,WAAW,oBAAoB,uBAAuB,aAAa,KAAK;AAAA;AAAA,SAG1E,qBAAqB,iBAAkD;AAC1E,eAAW,iBAAiB,iBAAiB;AACzC,UAAI,cAAc,QAAQ,KAAK,iBAAiB;AAC5C,cAAM,IAAI,qBACN,sBAAsB,cAAc,8BACpC;AAAA;AAGR,WAAK,gBAAgB,cAAc,QAAQ;AAAA;AAAA;AAAA,SAI5C,iBAAiB,MAAmD;AACvE,WAAO,KAAK,gBAAgB;AAAA;AAAA,SAGzB,wBAAmD;AACtD,WAAO,OAAO,OAAO,KAAK;AAAA;AAAA,EAGtB,gBAAgB;AACpB,UAAM,8BAA8B,uBAAI,KAAK,WAAW,oBAAoB,aAAa;AACzF,eAAW,CAAC,IAAI,EAAE,WAAW,OAAO,QAAQ,8BAA8B;AACtE,WAAK,UAAU,MAAM,KAAK,eAAe,MAAM;AAAA;AAAA;AAAA,EAI/C,eAAe,MAAc,IAA+B;AAChE,QAAI,SAAS,6BAAY,MAAM;AAC3B,YAAM,IAAI,qBACN,iDACA;AAAA;AAGR,UAAM,WAAW,YAAW,iBAAiB;AAC7C,QAAI,aAAa,QAAW;AACxB,YAAM,IAAI,qBACN,iBAAiB,4BAA4B,SAC7C;AAAA;AAGR,UAAM,gBAAgB,uBAAI,KAAK,WAAW,mBAAmB,WAAW,IAAI;AAE5E,WAAO,SAAS,OAAO,KAAK,YAAY,IAAI;AAAA;AAAA,EAGxC,iBAAuB;AAC3B,QAAI,KAAK,eAAe,QAAW;AAE/B,YAAM,IAAI,MAAM;AAAA;AAEpB,SAAK,aAAa;AAClB,UAAM,+BAA+B,uBAAI,KAAK,WAAW,oBAAoB,cAAc;AAC3F,eAAW,CAAC,IAAI,EAAE,MAAM,UAAU,iBAAiB,OAAO,QAAQ,+BAA+B;AAE7F,UAAI,eAAe,QAAW;AAC1B,aAAK,WAAW,MAAM,KAAK,UAAU,kBAAkB,gBAAgB,MAAM;AAC7E;AAAA;AAEJ,YAAM,WAAW,KAAK,oBAAoB;AAC1C,UAAI,CAAC,UAAU;AACX,cAAM,IAAI,qBACN,eAAe,sCAAsC,+BAA+B,OAAO,KACvF,KAAK,WACP,KAAK,SACP;AAAA;AAGR,WAAK,WAAW,MAAM,SAAS,gBAAgB,MAAM;AAAA;AAAA;AAAA,EAIrD,gBAAoD;AACxD,QAAI,KAAK,eAAe,QAAW;AAE/B,YAAM,IAAI,MAAM;AAAA;AAGpB,WAAO,KAAK;AAAA;AAAA,EAGhB,oBAAoB,IAA2C;AAC3D,WAAO,KAAK,UAAU;AAAA;AAAA,EAG1B,iBAAiB,EAAE,WAAmD;AAClE,WAAO;AAAA,MAmBH,OAAO,wBAAK,IAAI;AAAA,QACZ,SAAS,MAAM;AACX,gBAAM,aAAa,KAAK;AACxB,gBAAM,CAAC,IAAI,YAAY,QAAQ,MAAM,KAAK;AAC1C,cAAI,CAAC,uBAAI,KAAK,YAAY,KAAK;AAC3B,kBAAM,IAAI,qBACN,uBAAuB,mCAAmC,MAAM,kCAChE;AAAA;AAGR,gBAAM,YAAY,WAAW;AAE7B,gBAAM,aAAa,UAAU,YAAY,UAAU,cAAc;AACjE,cAAI,CAAC,uBAAI,YAAY,WAAW;AAC5B,gBAAI,OAAO,KAAK,YAAY,WAAW,GAAG;AACtC,oBAAM,IAAI,qBACN,gBAAgB,MAAM,4CAA4C,oCAClE;AAAA;AAGR,kBAAM,IAAI,qBACN,gBAAgB,MAAM,kEAAkE,YAAY,OAAO,KACvG,YACF,KAAK,SACP;AAAA;AAIR,iBAAO,WAAW;AAAA;AAAA,SAEvB;AAAA;AAAA;AAAA,QAIL,OAAsB;AACxB,UAAM,aAAa,KAAK;AACxB,eAAW,CAAC,IAAI,cAAc,OAAO,QAAQ,aAAa;AACtD,UAAI,OAAO,UAAU,YAAY,YAAY;AACzC;AAAA;AAEJ,YAAM,UAAU,UAAU;AAC1B,UAAI,OAAO,KAAK,SAAS,WAAW,GAAG;AACnC,cAAM,WAAW,OAAO,OAAO,SAAS;AACxC,cAAM,SAAS,MAAM;AACrB,YAAI,WAAW,QAAW;AACtB,cAAI,KAAK,WAAW,yBAAyB;AACzC,iBAAK,WAAW,wBAAwB,IAAI;AAAA,iBACzC;AACH,oBAAQ,IAAI,GAAG,qBAAM,OAAO,GAAG,UAAU;AAAA;AAAA;AAAA;AAIrD,UAAI,OAAO,KAAK,SAAS,SAAS,GAAG;AACjC,cAAM,UAAoB;AAC1B,mBAAW,CAAC,MAAM,aAAa,OAAO,QAAQ,UAAU;AACpD,gBAAM,SAAS,MAAM;AACrB,cAAI,WAAW,QAAW;AACtB,oBAAQ,KAAK,GAAG,SAAS;AAAA;AAAA;AAGjC,YAAI,KAAK,WAAW,yBAAyB;AACzC,eAAK,WAAW,wBAAwB,IAAI;AAAA,eACzC;AACH,kBAAQ,IAAI,qBAAM,OAAO,GAAG;AAC5B,kBAAQ,IAAI,QAAQ,IAAI,CAAC,SAAS,KAAK,QAAQ,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM5D,mBAAmB;AACvB,UAAM,0BAA0B,uBAAI,KAAK,WAAW,oBAAoB,cAAc;AAKtF,eAAW,CAAC,IAAI,oBAAoB,OAAO,QAAQ,0BAA0B;AACzE,UAAI,gBAAgB,SAAS,QAAW;AACpC,cAAM,IAAI,qBACN,kBAAkB;AAAA,sFAElB;AAAA;AAGR,YAAM,iBAAiB,KAAK,kBAAkB,gBAAgB;AAC9D,UAAI,mBAAmB,QAAW;AAC9B,cAAM,IAAI,qBACN,kBAAkB,4BAA4B,gBAAgB;AAAA,sFAE9D;AAAA;AAGR,UAAI,eAAe,aAAa,QAAW;AACvC;AAAA;AAGJ,iBAAW,CAAC,SAAS,sBAAsB,OAAO,QAAQ,eAAe,WAAW;AAChF,aAAK,SAAS,GAAG,MAAM,aAAa;AAAA,UAChC,iBAAiB,CAAC;AAAA,UAClB,OAAO,kBAAkB;AAAA,UACzB,SAAS,kBAAkB;AAAA;AAG/B,aAAK,MAAM,GAAG,MAAM,WAAW,aAAa,MAAM;AAE9C,gBAAM,YAAY,KAAK,gBAAgB;AAEvC,iBAAO,kBAAkB,QAAQ,KAAK,WAAW,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA,QAMxD,aAA4B;AACtC,UAAM,aAAa,KAAK;AACxB,eAAW,CAAC,EAAE,cAAc,OAAO,QAAQ,aAAa;AACpD,UAAI,UAAU,eAAe,QAAW;AACpC,cAAM,UAAU;AAAA;AAAA;AAAA;AAAA,QAKd,YAA2B;AACrC,UAAM,aAAa,KAAK;AACxB,eAAW,CAAC,EAAE,cAAc,OAAO,QAAQ,aAAa;AACpD,UAAI,UAAU,cAAc,QAAW;AACnC,cAAM,UAAU;AAAA;AAAA;AAAA;AAAA,EAKpB,uBAAuB;AAE3B,UAAM,gBAAgB,IAAI,wCAAqB,IAAI;AACnD,UAAM,gBAAgB,CAAI,UAAgB;AACtC,UAAI,UAAU,QAAW;AACrB,eAAO;AAAA;AAGX,aAAO,gCAAa,QAAQ,OAAO;AAAA,QAC/B,UAAU;AAAA,QACV,OAAQ,KAAK,UAAU,kBAAkC;AAAA;AAAA;AAGjE,SAAK,WAAW,QAAQ,WAAW,cAAc,KAAK,WAAW,QAAQ;AACzE,SAAK,WAAW,QAAQ,UAAU,cAAc,KAAK,WAAW,QAAQ;AACxE,SAAK,WAAW,QAAQ,SAAS,cAAc,KAAK,WAAW,QAAQ;AACvE,SAAK,WAAW,QAAQ,YAAY,cAAc,KAAK,WAAW,QAAQ;AAC1E,SAAK,WAAW,QAAQ,YAAY,cAAc,KAAK,WAAW,QAAQ;AAC1E,SAAK,WAAW,QAAQ,SAAS,cAAc,KAAK,WAAW,QAAQ;AACvE,SAAK,WAAW,QAAQ,UAAU,cAAc,KAAK,WAAW,QAAQ;AAExE,SAAK,WAAW,qBAAqB,cAAc,KAAK,WAAW;AAAA;AAAA,EAI/D,gCAAgC;AACpC,IAAC,KAAK,UAAU,kBAAkC;AAAA;AAAA,EAG9C,oBAA0B;AAnbtC;AAqbQ,UAAM,oBAAoB,uBAAI,KAAK,WAAW,oBAAoB,QAAQ;AAC1E,QAAI,kBAAkB,yBAAyB,OAAO;AAClD;AAAA;AAGJ,UAAM,aAAa,KAAK;AACxB,UAAM,aAAa,2BACf,OAAO,QAAQ,YAAY,IAAI,CAAC,CAAC,EAAE,eAAe;AAC9C,aAAQ,UAAU,cAAc,UAAU,gBAAgB;AAAA;AAGlE,QAAI,WAAW,WAAW,GAAG;AACzB;AAAA;AAGJ,UAAM,OAAO,WAAK,WAAW,QAAQ,SAAS,QAAjC,mBAAsC;AAEnD,QAAI,OAAO,SAAS,YAAY,gBAAgB,MAAM;AAClD,iBAAK,eAAL,mBAAiB,KAAK,GAAG;AAEzB;AAAA;AAGJ,SAAK,WAAW,QAAQ,SAAS,oBAAoB,WAAK,WAAW,QAAQ,SAAS,sBAAjC,YAAsD;AAC3G,SAAK,WAAW,QAAQ,SAAS,kBAAkB,KAAK,GAAG;AAAA;AAAA,QAGjD,QAAQ;AAClB,kCAAW,IAAI;AACf,kCAAW;AACX,UAAM,KAAK,WAAW,cAAc,MAAM;AAC1C,UAAM,iBAAiB,KAAK,WAAW,YAAY;AACnD,UAAM,2BAA2B,eAAe,OAAO;AACvD,UAAM,2BAA2B,KAAK,KAAK,KAAK,WAAW,YAAY,eAAe;AACtF,UAAM,aAAa,4BAAa;AAChC,UAAM,gBAAgB,yBAAK,KAAK,MAAM,WAAW;AACjD,kCAAW,UAAU;AACrB,kCAAW,IAAI;AACf,kCAAW,IAAI;AAAA;AAAA,EAGX,yBAAqD;AACzD,UAAM,SAAS,2BACX,YAAW,wBAAwB,IAAI,CAAC,kBAAkB,cAAc;AAG5E,WAAO;AAAA;AAAA,EAGH,kBAAkB,eAA6D;AACnF,eAAW,iBAAiB,YAAW,yBAAyB;AAC5D,YAAM,iBAAiB,cAAc,kBAAkB;AACvD,UAAI,mBAAmB,QAAW;AAC9B,eAAO;AAAA;AAAA;AAIf,WAAO;AAAA;AAAA;AAlaf;AAI4B,AAJ5B,WAI4B,kBAA2D;AAuavF,WAAW,kBAAkB,8BAAa;AAE1C,OAAO,UAAU;",
  "names": []
}
