{
  "version": 3,
  "sources": ["../../../src/providers/AwsProvider.ts"],
  "sourcesContent": ["import type { CfnOutput } from \"aws-cdk-lib\";\nimport { App, DefaultStackSynthesizer, Stack } from \"aws-cdk-lib\";\nimport { get, merge } from \"lodash\";\nimport type { AwsCfInstruction, AwsLambdaVpcConfig } from \"@serverless/typescript\";\nimport type { ProviderInterface } from \"@lift/providers\";\nimport type { ConstructInterface, StaticConstructInterface } from \"@lift/constructs\";\nimport {\n    DatabaseDynamoDBSingleTable,\n    Queue,\n    ServerSideWebsite,\n    SinglePageApp,\n    StaticWebsite,\n    Storage,\n    Vpc,\n    Webhook,\n} from \"@lift/constructs/aws\";\nimport { getStackOutput } from \"../CloudFormation\";\nimport type { CloudformationTemplate, Provider as LegacyAwsProvider, Serverless } from \"../types/serverless\";\nimport { awsRequest } from \"../classes/aws\";\nimport ServerlessError from \"../utils/error\";\n\nconst AWS_DEFINITION = {\n    type: \"object\",\n    properties: {},\n    additionalProperties: false,\n} as const;\n\nexport class AwsProvider implements ProviderInterface {\n    public static type = \"aws\";\n    public static schema = AWS_DEFINITION;\n    private static readonly constructClasses: Record<string, StaticConstructInterface> = {};\n\n    static registerConstructs(...constructClasses: StaticConstructInterface[]): void {\n        for (const constructClass of constructClasses) {\n            if (constructClass.type in this.constructClasses) {\n                throw new ServerlessError(\n                    `The construct type '${constructClass.type}' was registered twice`,\n                    \"LIFT_CONSTRUCT_TYPE_CONFLICT\"\n                );\n            }\n            this.constructClasses[constructClass.type] = constructClass;\n        }\n    }\n\n    static getConstructClass(type: string): StaticConstructInterface | undefined {\n        return this.constructClasses[type];\n    }\n\n    static getAllConstructClasses(): StaticConstructInterface[] {\n        return Object.values(this.constructClasses);\n    }\n\n    static create(serverless: Serverless): ProviderInterface {\n        return new this(serverless);\n    }\n\n    private readonly app: App;\n    public readonly stack: Stack;\n    public readonly region: string;\n    public readonly stackName: string;\n    private readonly legacyProvider: LegacyAwsProvider;\n    public naming: {\n        getStackName: () => string;\n        getLambdaLogicalId: (functionName: string) => string;\n        getRestApiLogicalId: () => string;\n        getHttpApiLogicalId: () => string;\n    };\n\n    constructor(private readonly serverless: Serverless) {\n        this.stackName = serverless.getProvider(\"aws\").naming.getStackName();\n        this.app = new App();\n        this.stack = new Stack(this.app, undefined, {\n            synthesizer: new DefaultStackSynthesizer({\n                generateBootstrapVersionRule: false,\n            }),\n        });\n        this.legacyProvider = serverless.getProvider(\"aws\");\n        this.naming = this.legacyProvider.naming;\n        this.region = serverless.getProvider(\"aws\").getRegion();\n        serverless.stack = this.stack;\n    }\n\n    createConstruct(type: string, id: string): ConstructInterface {\n        const Construct = AwsProvider.getConstructClass(type);\n        if (Construct === undefined) {\n            throw new ServerlessError(\n                `The construct '${id}' has an unknown type '${type}'\\n` +\n                    \"Find all construct types available here: https://github.com/getlift/lift#constructs\",\n                \"LIFT_UNKNOWN_CONSTRUCT_TYPE\"\n            );\n        }\n        const configuration = get(this.serverless.configurationInput.constructs, id, {});\n\n        return Construct.create(this, id, configuration);\n    }\n\n    addFunction(functionName: string, functionConfig: unknown): void {\n        if (!this.serverless.configurationInput.functions) {\n            // If serverless.yml does not contain any functions, bootstrapping a new empty functions config\n            this.serverless.configurationInput.functions = {};\n        }\n\n        merge(this.serverless.service.functions, {\n            [functionName]: functionConfig,\n        });\n        /**\n         * We must manually call `setFunctionNames()`: this is a function that normalizes functions.\n         * This function is called by the Framework, but we have to call it again because we add new\n         * functions after this function has already run. So our new function (that we add here)\n         * will not have been normalized.\n         */\n        this.serverless.service.setFunctionNames(this.serverless.processedInput.options);\n    }\n\n    /**\n     * @internal\n     */\n    setVpcConfig(securityGroups: AwsCfInstruction[], subnets: AwsCfInstruction[]): void {\n        if (this.getVpcConfig() !== null) {\n            throw new ServerlessError(\n                \"Can't register more than one VPC.\\n\" +\n                    'Either you have several \"vpc\" constructs \\n' +\n                    'or you already defined \"provider.vpc\" in serverless.yml',\n                \"LIFT_ONLY_ONE_VPC\"\n            );\n        }\n\n        this.serverless.service.provider.vpc = {\n            securityGroupIds: securityGroups, // TODO : merge with existing groups ?\n            subnetIds: subnets,\n        };\n    }\n\n    /**\n     * This function can be used by other constructs to reference\n     * global subnets or security groups in their resources\n     *\n     * @internal\n     */\n    getVpcConfig(): AwsLambdaVpcConfig | null {\n        return this.serverless.service.provider.vpc ?? null;\n    }\n\n    /**\n     * Resolves the value of a CloudFormation stack output.\n     */\n    async getStackOutput(output: CfnOutput): Promise<string | undefined> {\n        return getStackOutput(this, output);\n    }\n\n    /**\n     * Send a request to the AWS API.\n     */\n    request<Input, Output>(service: string, method: string, params: Input): Promise<Output> {\n        return awsRequest<Input, Output>(params, service, method, this.legacyProvider);\n    }\n\n    appendCloudformationResources(): void {\n        merge(this.serverless.service, {\n            resources: this.app.synth().getStackByName(this.stack.stackName).template as CloudformationTemplate,\n        });\n    }\n}\n\n/**\n * This is representative of a possible public API to register constructs. How it would work:\n * - 3rd party developers create a custom construct\n * - they also create a plugin that calls:\n *       AwsProvider.registerConstructs(Foo, Bar);\n *  If they use TypeScript, `registerConstructs()` will validate that the construct class\n *  implements both static fields (type, schema, create(), \u2026) and non-static fields (outputs(), references(), \u2026).\n */\nAwsProvider.registerConstructs(\n    Storage,\n    Queue,\n    Webhook,\n    SinglePageApp,\n    StaticWebsite,\n    Vpc,\n    DatabaseDynamoDBSingleTable,\n    ServerSideWebsite\n);\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AACA,yBAAoD;AACpD,oBAA2B;AAI3B,iBASO;AACP,4BAA+B;AAE/B,kBAA2B;AAC3B,mBAA4B;AAE5B,MAAM,iBAAiB;AAAA,EACnB,MAAM;AAAA,EACN,YAAY;AAAA,EACZ,sBAAsB;AAAA;AAGnB,2BAA+C;AAAA,EAyClD,YAA6B,YAAwB;AAAxB;AACzB,SAAK,YAAY,WAAW,YAAY,OAAO,OAAO;AACtD,SAAK,MAAM,IAAI;AACf,SAAK,QAAQ,IAAI,yBAAM,KAAK,KAAK,QAAW;AAAA,MACxC,aAAa,IAAI,2CAAwB;AAAA,QACrC,8BAA8B;AAAA;AAAA;AAGtC,SAAK,iBAAiB,WAAW,YAAY;AAC7C,SAAK,SAAS,KAAK,eAAe;AAClC,SAAK,SAAS,WAAW,YAAY,OAAO;AAC5C,eAAW,QAAQ,KAAK;AAAA;AAAA,SA/CrB,sBAAsB,kBAAoD;AAC7E,eAAW,kBAAkB,kBAAkB;AAC3C,UAAI,eAAe,QAAQ,KAAK,kBAAkB;AAC9C,cAAM,IAAI,qBACN,uBAAuB,eAAe,8BACtC;AAAA;AAGR,WAAK,iBAAiB,eAAe,QAAQ;AAAA;AAAA;AAAA,SAI9C,kBAAkB,MAAoD;AACzE,WAAO,KAAK,iBAAiB;AAAA;AAAA,SAG1B,yBAAqD;AACxD,WAAO,OAAO,OAAO,KAAK;AAAA;AAAA,SAGvB,OAAO,YAA2C;AACrD,WAAO,IAAI,KAAK;AAAA;AAAA,EA6BpB,gBAAgB,MAAc,IAAgC;AAC1D,UAAM,YAAY,aAAY,kBAAkB;AAChD,QAAI,cAAc,QAAW;AACzB,YAAM,IAAI,qBACN,kBAAkB,4BAA4B;AAAA,sFAE9C;AAAA;AAGR,UAAM,gBAAgB,uBAAI,KAAK,WAAW,mBAAmB,YAAY,IAAI;AAE7E,WAAO,UAAU,OAAO,MAAM,IAAI;AAAA;AAAA,EAGtC,YAAY,cAAsB,gBAA+B;AAC7D,QAAI,CAAC,KAAK,WAAW,mBAAmB,WAAW;AAE/C,WAAK,WAAW,mBAAmB,YAAY;AAAA;AAGnD,6BAAM,KAAK,WAAW,QAAQ,WAAW;AAAA,OACpC,eAAe;AAAA;AAQpB,SAAK,WAAW,QAAQ,iBAAiB,KAAK,WAAW,eAAe;AAAA;AAAA,EAM5E,aAAa,gBAAoC,SAAmC;AAChF,QAAI,KAAK,mBAAmB,MAAM;AAC9B,YAAM,IAAI,qBACN;AAAA;AAAA,0DAGA;AAAA;AAIR,SAAK,WAAW,QAAQ,SAAS,MAAM;AAAA,MACnC,kBAAkB;AAAA,MAClB,WAAW;AAAA;AAAA;AAAA,EAUnB,eAA0C;AA3I9C;AA4IQ,WAAO,WAAK,WAAW,QAAQ,SAAS,QAAjC,YAAwC;AAAA;AAAA,QAM7C,eAAe,QAAgD;AACjE,WAAO,0CAAe,MAAM;AAAA;AAAA,EAMhC,QAAuB,SAAiB,QAAgB,QAAgC;AACpF,WAAO,4BAA0B,QAAQ,SAAS,QAAQ,KAAK;AAAA;AAAA,EAGnE,gCAAsC;AAClC,6BAAM,KAAK,WAAW,SAAS;AAAA,MAC3B,WAAW,KAAK,IAAI,QAAQ,eAAe,KAAK,MAAM,WAAW;AAAA;AAAA;AAAA;AApItE;AACW,AADX,YACW,OAAO;AACP,AAFX,YAEW,SAAS;AACC,AAHrB,YAGqB,mBAA6D;AA8IzF,YAAY,mBACR,oBACA,kBACA,oBACA,0BACA,0BACA,gBACA,wCACA;",
  "names": []
}
