{
  "version": 3,
  "sources": ["../../../src/providers/StripeProvider.ts"],
  "sourcesContent": ["import { existsSync, readFileSync } from \"fs\";\nimport { homedir } from \"os\";\nimport { resolve } from \"path\";\nimport { parse as tomlParse } from \"toml\";\nimport { get, has } from \"lodash\";\nimport { Stripe } from \"stripe\";\nimport type { ConstructInterface, StaticConstructInterface } from \"@lift/constructs\";\nimport type { ProviderInterface } from \"@lift/providers\";\nimport type { FromSchema } from \"json-schema-to-ts\";\nimport type { Serverless } from \"../types/serverless\";\nimport ServerlessError from \"../utils/error\";\n\nconst STRIPE_DEFINITION = {\n    type: \"object\",\n    properties: {\n        profile: { type: \"string\" },\n    },\n    additionalProperties: false,\n} as const;\n\ntype StripeConfiguration = {\n    account_id: string;\n    device_name: string;\n    live_mode_api_key: string;\n    live_mode_publishable_key: string;\n    test_mode_api_key: string;\n    test_mode_publishable_key: string;\n};\n\ntype StripeConfigFile = { color: string } & Record<string, StripeConfiguration>;\ntype Configuration = FromSchema<typeof STRIPE_DEFINITION>;\n\nexport class StripeProvider implements ProviderInterface {\n    public static type = \"stripe\";\n    public static schema = STRIPE_DEFINITION;\n    private static readonly constructClasses: Record<string, StaticConstructInterface> = {};\n\n    static registerConstructs(...constructClasses: StaticConstructInterface[]): void {\n        for (const constructClass of constructClasses) {\n            if (constructClass.type in this.constructClasses) {\n                throw new ServerlessError(\n                    `The construct type '${constructClass.type}' was registered twice`,\n                    \"LIFT_CONSTRUCT_TYPE_CONFLICT\"\n                );\n            }\n            this.constructClasses[constructClass.type] = constructClass;\n        }\n    }\n\n    static getConstructClass(type: string): StaticConstructInterface | undefined {\n        return this.constructClasses[type];\n    }\n\n    static getAllConstructClasses(): StaticConstructInterface[] {\n        return Object.values(this.constructClasses);\n    }\n\n    static create(serverless: Serverless, id: string, { profile }: Configuration): StripeProvider {\n        return new this(serverless, id, profile);\n    }\n\n    private config: { apiKey: string; accountId?: string };\n    public sdk: Stripe;\n    constructor(private readonly serverless: Serverless, private readonly id: string, profile?: string) {\n        this.config = this.resolveConfiguration(profile);\n        this.sdk = new Stripe(this.config.apiKey, { apiVersion: \"2020-08-27\" });\n    }\n\n    createConstruct(type: string, id: string): ConstructInterface {\n        const Construct = StripeProvider.getConstructClass(type);\n        if (Construct === undefined) {\n            throw new ServerlessError(\n                `The construct '${id}' has an unknown type '${type}'\\n` +\n                    \"Find all construct types available here: https://github.com/getlift/lift#constructs\",\n                \"LIFT_UNKNOWN_CONSTRUCT_TYPE\"\n            );\n        }\n        const configuration = get(this.serverless.configurationInput.constructs, id, {});\n\n        return Construct.create(this, id, configuration);\n    }\n\n    resolveConfiguration(profile?: string): { apiKey: string; accountId?: string } {\n        // Sourcing from env\n        if (profile === undefined && typeof process.env.STRIPE_API_KEY === \"string\") {\n            return { apiKey: process.env.STRIPE_API_KEY };\n        }\n\n        // Sourcing from TOML configuration file\n        const configsPath = process.env.XDG_CONFIG_HOME ?? resolve(homedir(), \".config\");\n        const stripeConfigFilePath = resolve(configsPath, \"stripe/config.toml\");\n        if (!existsSync(stripeConfigFilePath)) {\n            throw new ServerlessError(\n                \"Could not source any Stripe configuration. Have you set your STRIPE_API_KEY environment?\",\n                \"STRIPE_MISSING_CONFIGURATION\"\n            );\n        }\n\n        const stripeConfigurationFileContent = readFileSync(stripeConfigFilePath);\n        const stripeConfigurations = tomlParse(stripeConfigurationFileContent.toString()) as StripeConfigFile;\n        if (profile !== undefined) {\n            if (!has(stripeConfigurations, profile)) {\n                throw new ServerlessError(\n                    `There is no ${profile} profile in your stripe configuration. Found profiles are ${Object.keys(\n                        stripeConfigurations\n                    )\n                        .filter((stripeConfiguration) => stripeConfiguration !== \"color\")\n                        .join(\", \")}`,\n                    \"STRIPE_MISSING_PROFILE\"\n                );\n            }\n            const stripeConfig = stripeConfigurations[profile];\n\n            return {\n                apiKey: stripeConfig.test_mode_api_key,\n                accountId: stripeConfig.account_id,\n            };\n        }\n        // Fallback to default profile\n        if (!has(stripeConfigurations, \"default\")) {\n            throw new ServerlessError(\n                `There is no default profile in your stripe configuration. Please provide one of the found profiles: ${Object.keys(\n                    stripeConfigurations\n                )\n                    .filter((stripeConfiguration) => stripeConfiguration !== \"color\")\n                    .join(\", \")}`,\n                \"STRIPE_MISSING_DEFAULT_PROFILE\"\n            );\n        }\n        const defaultStripeConfig = stripeConfigurations.default;\n\n        return {\n            apiKey: defaultStripeConfig.test_mode_api_key,\n            accountId: defaultStripeConfig.account_id,\n        };\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,gBAAyC;AACzC,gBAAwB;AACxB,kBAAwB;AACxB,kBAAmC;AACnC,oBAAyB;AACzB,oBAAuB;AAKvB,mBAA4B;AAE5B,MAAM,oBAAoB;AAAA,EACtB,MAAM;AAAA,EACN,YAAY;AAAA,IACR,SAAS,EAAE,MAAM;AAAA;AAAA,EAErB,sBAAsB;AAAA;AAenB,8BAAkD;AAAA,EA+BrD,YAA6B,YAAyC,IAAY,SAAkB;AAAvE;AAAyC;AAClE,SAAK,SAAS,KAAK,qBAAqB;AACxC,SAAK,MAAM,IAAI,qBAAO,KAAK,OAAO,QAAQ,EAAE,YAAY;AAAA;AAAA,SA5BrD,sBAAsB,kBAAoD;AAC7E,eAAW,kBAAkB,kBAAkB;AAC3C,UAAI,eAAe,QAAQ,KAAK,kBAAkB;AAC9C,cAAM,IAAI,qBACN,uBAAuB,eAAe,8BACtC;AAAA;AAGR,WAAK,iBAAiB,eAAe,QAAQ;AAAA;AAAA;AAAA,SAI9C,kBAAkB,MAAoD;AACzE,WAAO,KAAK,iBAAiB;AAAA;AAAA,SAG1B,yBAAqD;AACxD,WAAO,OAAO,OAAO,KAAK;AAAA;AAAA,SAGvB,OAAO,YAAwB,IAAY,EAAE,WAA0C;AAC1F,WAAO,IAAI,KAAK,YAAY,IAAI;AAAA;AAAA,EAUpC,gBAAgB,MAAc,IAAgC;AAC1D,UAAM,YAAY,gBAAe,kBAAkB;AACnD,QAAI,cAAc,QAAW;AACzB,YAAM,IAAI,qBACN,kBAAkB,4BAA4B;AAAA,sFAE9C;AAAA;AAGR,UAAM,gBAAgB,uBAAI,KAAK,WAAW,mBAAmB,YAAY,IAAI;AAE7E,WAAO,UAAU,OAAO,MAAM,IAAI;AAAA;AAAA,EAGtC,qBAAqB,SAA0D;AAlFnF;AAoFQ,QAAI,YAAY,UAAa,OAAO,QAAQ,IAAI,mBAAmB,UAAU;AACzE,aAAO,EAAE,QAAQ,QAAQ,IAAI;AAAA;AAIjC,UAAM,cAAc,cAAQ,IAAI,oBAAZ,YAA+B,yBAAQ,0BAAW;AACtE,UAAM,uBAAuB,yBAAQ,aAAa;AAClD,QAAI,CAAC,0BAAW,uBAAuB;AACnC,YAAM,IAAI,qBACN,4FACA;AAAA;AAIR,UAAM,iCAAiC,4BAAa;AACpD,UAAM,uBAAuB,uBAAU,+BAA+B;AACtE,QAAI,YAAY,QAAW;AACvB,UAAI,CAAC,uBAAI,sBAAsB,UAAU;AACrC,cAAM,IAAI,qBACN,eAAe,oEAAoE,OAAO,KACtF,sBAEC,OAAO,CAAC,wBAAwB,wBAAwB,SACxD,KAAK,SACV;AAAA;AAGR,YAAM,eAAe,qBAAqB;AAE1C,aAAO;AAAA,QACH,QAAQ,aAAa;AAAA,QACrB,WAAW,aAAa;AAAA;AAAA;AAIhC,QAAI,CAAC,uBAAI,sBAAsB,YAAY;AACvC,YAAM,IAAI,qBACN,uGAAuG,OAAO,KAC1G,sBAEC,OAAO,CAAC,wBAAwB,wBAAwB,SACxD,KAAK,SACV;AAAA;AAGR,UAAM,sBAAsB,qBAAqB;AAEjD,WAAO;AAAA,MACH,QAAQ,oBAAoB;AAAA,MAC5B,WAAW,oBAAoB;AAAA;AAAA;AAAA;AArGpC;AACW,AADX,eACW,OAAO;AACP,AAFX,eAEW,SAAS;AACC,AAHrB,eAGqB,mBAA6D;",
  "names": []
}
