{
  "version": 3,
  "sources": ["../../../src/utils/s3-sync.ts"],
  "sourcesContent": ["import type {\n    DeleteObjectsOutput,\n    DeleteObjectsRequest,\n    ListObjectsV2Output,\n    ListObjectsV2Request,\n    PutObjectOutput,\n    PutObjectRequest,\n    Object as S3Object,\n} from \"aws-sdk/clients/s3\";\nimport * as fs from \"fs\";\nimport * as util from \"util\";\nimport * as path from \"path\";\nimport * as crypto from \"crypto\";\nimport { lookup } from \"mime-types\";\nimport { chunk, flatten } from \"lodash\";\nimport type { AwsProvider } from \"@lift/providers\";\nimport ServerlessError from \"./error\";\nimport { getUtils } from \"./logger\";\n\nconst readdir = util.promisify(fs.readdir);\nconst stat = util.promisify(fs.stat);\n\ntype S3Objects = Record<string, S3Object>;\n\n/**\n * Synchronize a local folder to a S3 bucket.\n *\n * @return True if some changes were uploaded.\n */\nexport async function s3Sync({\n    aws,\n    localPath,\n    targetPathPrefix,\n    bucketName,\n}: {\n    aws: AwsProvider;\n    localPath: string;\n    targetPathPrefix?: string;\n    bucketName: string;\n}): Promise<{ hasChanges: boolean; fileChangeCount: number }> {\n    let hasChanges = false;\n    let fileChangeCount = 0;\n    const filesToUpload: string[] = await listFilesRecursively(localPath);\n    const existingS3Objects = await s3ListAll(aws, bucketName, targetPathPrefix);\n\n    // Upload files by chunks\n    let skippedFiles = 0;\n    for (const batch of chunk(filesToUpload, 2)) {\n        await Promise.all(\n            batch.map(async (file) => {\n                const targetKey = targetPathPrefix !== undefined ? path.posix.join(targetPathPrefix, file) : file;\n                const fileContent = fs.readFileSync(path.posix.join(localPath, file));\n\n                // Check that the file isn't already uploaded\n                if (targetKey in existingS3Objects) {\n                    const existingObject = existingS3Objects[targetKey];\n                    const etag = computeS3ETag(fileContent);\n                    if (etag === existingObject.ETag) {\n                        skippedFiles++;\n\n                        return;\n                    }\n                }\n\n                getUtils().log.verbose(`Uploading ${file}`);\n                await s3Put(aws, bucketName, targetKey, fileContent);\n                hasChanges = true;\n                fileChangeCount++;\n            })\n        );\n    }\n    if (skippedFiles > 0) {\n        getUtils().log.verbose(`Skipped uploading ${skippedFiles} unchanged files`);\n    }\n\n    const targetKeys = filesToUpload.map((file) =>\n        targetPathPrefix !== undefined ? path.posix.join(targetPathPrefix, file) : file\n    );\n    const keysToDelete = findKeysToDelete(Object.keys(existingS3Objects), targetKeys);\n    if (keysToDelete.length > 0) {\n        keysToDelete.map((key) => {\n            getUtils().log.verbose(`Deleting ${key}`);\n            fileChangeCount++;\n        });\n        await s3Delete(aws, bucketName, keysToDelete);\n        hasChanges = true;\n    }\n\n    return { hasChanges, fileChangeCount };\n}\n\nasync function listFilesRecursively(directory: string): Promise<string[]> {\n    const items = await readdir(directory);\n\n    const files = await Promise.all(\n        items.map(async (fileName) => {\n            const fullPath = path.posix.join(directory, fileName);\n            const fileStat = await stat(fullPath);\n            if (fileStat.isFile()) {\n                return [fileName];\n            } else if (fileStat.isDirectory()) {\n                const subFiles = await listFilesRecursively(fullPath);\n\n                return subFiles.map((subFileName) => path.posix.join(fileName, subFileName));\n            }\n\n            return [];\n        })\n    );\n\n    return flatten(files);\n}\n\nasync function s3ListAll(aws: AwsProvider, bucketName: string, pathPrefix?: string): Promise<S3Objects> {\n    let result;\n    let continuationToken = undefined;\n    const objects: Record<string, S3Object> = {};\n    do {\n        result = await aws.request<ListObjectsV2Request, ListObjectsV2Output>(\"S3\", \"listObjectsV2\", {\n            Bucket: bucketName,\n            Prefix: pathPrefix,\n            MaxKeys: 1000,\n            ContinuationToken: continuationToken,\n        });\n        (result.Contents ?? []).forEach((object) => {\n            if (object.Key === undefined) {\n                return;\n            }\n            objects[object.Key] = object;\n        });\n        continuationToken = result.NextContinuationToken;\n    } while (result.IsTruncated === true);\n\n    return objects;\n}\n\nfunction findKeysToDelete(existing: string[], target: string[]): string[] {\n    // Returns every key that shouldn't exist anymore\n    return existing.filter((key) => target.indexOf(key) === -1);\n}\n\nexport async function s3Put(aws: AwsProvider, bucket: string, key: string, fileContent: Buffer): Promise<void> {\n    let contentType = lookup(key);\n    if (contentType === false) {\n        contentType = \"application/octet-stream\";\n    }\n    await aws.request<PutObjectRequest, PutObjectOutput>(\"S3\", \"putObject\", {\n        Bucket: bucket,\n        Key: key,\n        Body: fileContent,\n        ContentType: contentType,\n    });\n}\n\nasync function s3Delete(aws: AwsProvider, bucket: string, keys: string[]): Promise<void> {\n    const response = await aws.request<DeleteObjectsRequest, DeleteObjectsOutput>(\"S3\", \"deleteObjects\", {\n        Bucket: bucket,\n        Delete: {\n            Objects: keys.map((key) => {\n                return {\n                    Key: key,\n                };\n            }),\n        },\n    });\n\n    // S3 deleteObjects operation will fail silently\n    // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#deleteObjects-property\n    if (response.Errors !== undefined && response.Errors.length !== 0) {\n        response.Errors.forEach((error) => console.log(error));\n        throw new ServerlessError(\n            `Unable to delete some files in S3. The \"static-website\" and \"server-side-website\" construct require the s3:DeleteObject IAM permissions to synchronize files to S3, is it missing from your deployment policy?`,\n            \"LIFT_S3_DELETE_OBJECTS_FAILURE\"\n        );\n    }\n}\n\nexport function computeS3ETag(fileContent: Buffer): string {\n    return `\"${crypto.createHash(\"md5\").update(fileContent).digest(\"hex\")}\"`;\n}\n"],
  "mappings": "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",
  "names": []
}
