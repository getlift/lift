{
  "version": 3,
  "sources": ["../../../src/types/serverless.ts"],
  "sourcesContent": ["import type { AWS } from \"@serverless/typescript\";\nimport type { Stack } from \"aws-cdk-lib\";\n\nexport type Hook = () => void | Promise<void>;\n\nexport type VariableResolver = {\n    /**\n     * When using such expression in service file ${foo(param1, param2):address}, resolve will be invoked with the following values:\n     *  - address: address\n     *  - params: [param1, param2]\n     *  - resolveConfigurationProperty: use to resolve other parts of the service file. Usage: `await resolveConfigurationProperty([\"provider\", \"stage\"])` will resolve provider.stage value\n     *  - options: CLI options passed to the command\n     */\n    resolve: (context: {\n        address: string;\n        params: string[];\n        resolveConfigurationProperty: string;\n        options: Record<string, string>;\n    }) => { value: string | Record<string, unknown> } | Promise<{ value: string | Record<string, unknown> }>;\n};\nexport type DeprecatedVariableResolver = (variable: string) => Promise<string | Record<string, unknown>>;\n\nexport type Provider = {\n    naming: {\n        getStackName: () => string;\n        getLambdaLogicalId: (functionName: string) => string;\n        getRestApiLogicalId: () => string;\n        getHttpApiLogicalId: () => string;\n        getCompiledTemplateFileName: () => string;\n    };\n    getRegion: () => string;\n    /**\n     * Send a request to the AWS API.\n     */\n    request: <Input, Output>(service: string, method: string, params: Input) => Promise<Output>;\n};\n\nexport type Serverless = {\n    // To use only in tests\n    stack: Stack;\n    serviceDir: string;\n    pluginManager: {\n        addPlugin: (plugin: unknown) => void;\n        spawn: (command: string) => Promise<void>;\n    };\n    configSchemaHandler: {\n        defineTopLevelProperty: (pluginName: string, schema: Record<string, unknown>) => void;\n    };\n    configurationInput: AWS & {\n        constructs?: Record<string, { type: string; provider?: string }>;\n        providers?: Record<string, { type: string }>;\n    };\n    service: AWS & {\n        setFunctionNames(rawOptions: Record<string, unknown>): void;\n    };\n    processedInput: {\n        commands: unknown;\n        options: Record<string, unknown>;\n    };\n    getProvider: (provider: \"aws\") => Provider;\n    addServiceOutputSection?(section: string, content: string | string[]): void;\n};\n\nexport type CloudformationTemplate = AWS[\"resources\"];\n\nexport type CommandsDefinition = Record<\n    string,\n    {\n        lifecycleEvents?: string[];\n        commands?: CommandsDefinition;\n        usage?: string;\n        options?: {\n            [name: string]: {\n                usage: string;\n                required?: boolean;\n                shortcut?: string;\n            };\n        };\n    }\n>;\n\nexport type CliOptions = Record<string, string | boolean | string[]>;\n"],
  "mappings": ";;AAAA;",
  "names": []
}
